#include <string.h>
#include "nmp_gu.h"
#include "nmp_debug.h"
#include "nmp_guid.h"
#include "nmp_policy.h"
#include "nmp_utility.h"
#include "nmp_sysctl.h"


#define TIME_STR_LEN	16

static void
nmp_dump_day_seg(gpointer data, gpointer user_data)
{
	NmpTimeSegment *seg = (NmpTimeSegment*)data;
	FILE *fp = (FILE*)user_data;
	gchar start[TIME_STR_LEN], end[TIME_STR_LEN];
	const gchar* week_day[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
	
	if (seg->seg_type == TS_TYPE_DAY)
	{
		nmp_make_str_from_seconds(seg->start, start, TIME_STR_LEN);
		nmp_make_str_from_seconds(seg->end - 1, end, TIME_STR_LEN);	

		fprintf(
			fp,
			"    %s %s ~ %s\n",
			week_day[seg->time.day.day_of_week],
			start,
			end
		);
	}
}


static void
nmp_dump_date_seg(gpointer data, gpointer user_data)
{
	NmpTimeSegment *seg = (NmpTimeSegment*)data;
	FILE *fp = (FILE*)user_data;
	gchar start[TIME_STR_LEN], end[TIME_STR_LEN];

	if (seg->seg_type == TS_TYPE_DATE)
	{
		nmp_make_str_from_seconds(seg->start, start, TIME_STR_LEN);
		nmp_make_str_from_seconds(seg->end - 1, end, TIME_STR_LEN);

		fprintf(
			fp,
			"    %04d-%02d-%02d %s ~ %s\n",
			seg->time.date.year,
			seg->time.date.month,
			seg->time.date.date,
			start,
			end
		);
	}
}


static __inline__ void
__nmp_policy_dump(NmpPolicy *p, FILE *fp)
{
	fprintf(fp, " @date:\n");
	g_list_foreach(p->time_segs, nmp_dump_date_seg, fp);

	fprintf(fp, " @weekday:\n");
	g_list_foreach(p->time_segs, nmp_dump_day_seg, fp);

	fprintf(fp, "\n");
}


void
nmp_policy_dump(NmpPolicy *p, FILE *fp)
{
	g_assert(p != NULL && fp != NULL);

	g_mutex_lock(p->mutex);
	__nmp_policy_dump(p, fp);
	g_mutex_unlock(p->mutex);
}


static __inline__ void
__nmp_gu_dump_policy(NmpGuPool *p, NmpGu *gu)
{
	fprintf(
		p->dump_fp,
		"(%d) '%s, %s'\n",
		++p->dump_total,
		gu->guid.domain_id,
		gu->guid.guid
	);

	fprintf(
		p->dump_fp,
		" @state: %s\n",
		gu->rec_state ? "'RECORDING'" : "'IDLE'"
	);

	if (gu->time_policy)
	{
		nmp_policy_dump(gu->time_policy, p->dump_fp);
	}
	else
	{
		fprintf(p->dump_fp, "\n");
	}
}


static void
nmp_gu_dump_policy(gpointer key, gpointer value,
	gpointer user_data)
{
	NmpGuPool *p;
	NmpGu *gu;
	g_assert(key == value);

	p = (NmpGuPool*)user_data;
	gu = (NmpGu*)value;

	__nmp_gu_dump_policy(p, gu);
}


static __inline__ FILE *
nmp_policy_dump_open( void )
{
	FILE *fp;
	gchar dir[PATH_MAX];

	snprintf(
		dir,
		PATH_MAX,
		"%s/Nmp-mss.pol",
		(gchar*)nmp_get_sysctl_value(SC_LOG_PATH)
	);

	dir[PATH_MAX -1 ] = 0;

	fp = fopen(dir, "w");
	if (!fp)
	{
		nmp_warning(
			"dump-policy, open '%s' for writing failed.",
			dir
		);
	}

	return fp;
}


static __inline__ void
__dump_begin(NmpGuPool *p)
{
	time_t now;
	const gchar *title = "# This file was generated by mss\n"
						 "# At";

	now = time(NULL);
	fprintf(p->dump_fp, "%s %s\n", title, ctime(&now));
}


static __inline__ void
__dump_end(NmpGuPool *p)
{
}


void
nmp_policy_pool_dump(NmpGuPool *p)
{
	FILE *fp = nmp_policy_dump_open();
	if (fp)
	{
		p->dump_fp = fp;
		p->dump_total = 0;

		__dump_begin(p);

		g_hash_table_foreach(p->hash_table,
						    nmp_gu_dump_policy,
						    p);
						 
		__dump_end(p);

		fclose(fp);
		p->dump_fp = NULL;
	}
}


//:~ End
